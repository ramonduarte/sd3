\documentclass[a4paper,12pt]{article}

    \usepackage{graphicx} % Required for the inclusion of images
    \usepackage{natbib} % Required to change bibliography style to APA
    \usepackage{url}
    \usepackage[portuguese]{babel}
    \usepackage[utf8]{inputenc}
    \usepackage[T1]{fontenc}
    %     \usepackage{amsmath} % Required for some math elements 
        
    %     \setlength\parindent{0pt} % Removes all indentation from paragraphs
        
    % \renewcommand{\labelenumi}{\alph{enumi}.} % Make numbering in the enumerate environment by letter rather than number (e.g. section 6)
    

    %----------------------------------------------------------------------------------------
    %	DOCUMENT INFORMATION
    %----------------------------------------------------------------------------------------

    \title{Relatório do Trabalho Prático 3} % Title
    % \author{Ramon \textsc{Melo}} % Author name
    % \date{\today} % Date for the report

    \begin{document}

        \maketitle % Insert the title, author and date

        \begin{center}
            \begin{tabular}{l r}
                % Data: & \today \\ % Date the experiment was performed
                Aluno: & Ramon Melo \\ % Partner names
                Professor: & Daniel Figueiredo % Instructor/supervisor
            \end{tabular}
        \end{center}

        % If you wish to include an abstract, uncomment the lines below
        % \begin{abstract}
        % Abstract text
        % \end{abstract}

        %----------------------------------------------------------------------------------------
        %	SECTION 1
        %----------------------------------------------------------------------------------------
        
        \section{Objetivo}
        
            Construir um sistema distribuído cujo mecanismo de ordenação total de eventos seja baseado no algoritmo \em{Totally Ordered Multicast}, utilizando o relógio lógico de Lamport como ordenador.
            
            % If you have more than one objective, uncomment the below:
            %\begin{description}
            %\item[First Objective] \hfill \\
            %Objective 1 text
            %\item[Second Objective] \hfill \\
            %Objective 2 text
            %\end{description}
            
            % \subsection{Definições}
            % \label{definitions}
            % \begin{description}
            % \item[Stoichiometry]
            % The relationship between the relative quantities of substances taking part in a reaction or forming a compound, typically a ratio of whole integers.
            % \item[Atomic mass]
            % The mass of an atom of a chemical element expressed in atomic mass units. It is approximately equivalent to the number of protons and neutrons in the atom (the mass number) or to the average number allowing for the relative abundances of different isotopes. 
            % \end{description}

        %----------------------------------------------------------------------------------------
        %	SECTION 2
        %----------------------------------------------------------------------------------------
        
        \section{Decisões de Projeto}
        
            \em{}Ao contrário dos trabalhos anteriores, a ordenação total de eventos distribuídos ocorre numa camada de abstração significativamente acima do hardware, de forma que implementações de baixo nível e acesso direto ao metal não compõem mais o conjunto de ferramentas desejável ao desenvolvimento da aplicação.
            Pelo contrário, bibliotecas de \emph{sockets}, processos e \emph{user-level threads} estão disponíveis em praticamente todas as linguagens de programação.
            Desta forma, deseja-se do ecossistema características como o suporte a construtos de programação orientada a objetos, tais como herança e polimorfismo; legibilidade do código; e agnosticismo em relação ao sistema operacional.
            
            A linguagem escolhida para este trabalho foi Python 3.5, edição que é nativa à maioria esmagadora de sistemas operacionais baseados no padrão POSIX.
            Em especial, esta versão é significativamente mais eficiente que as baseadas em Python 2 - mais tradicionais - e traz nativamente bibliotecas como a \texttt{multiprocessing}\cite{WEBSITE:8} (\emph{user-level threads} em concorrência, uma das poucas implementações que suporta o ecossistema Windows).
            
            Dada a natureza dos requisitos, que exige estruturas de dados razoavelmente similares mas autônomas, e ao prazo de entrega, que forçou a realização de \emph{sprints} bastante curtos (em média, dois por semana), o paradigma de orientação a objetos foi uma escolha natural.

            Conforme sugestão do enunciado, a comunicação interprocessual foi mantida através de \emph{sockets} TCP, o que, na prática, implica a premissa de que a rede física subposta é confiável, ou seja, mensagens não são perdidas (e, portanto, não precisam ser reenviadas) e chegam convenientemente de acordo com a ordem em que foram enviadas (\cite{BOOK:1}).
            Esta premissa pode ser considerada verdadeira para \emph{sockets} locais, que não dependem de canais externos ao sistema operacional para completarem o percurso.
            Por esta razão, os estudos de caso foram realizados no mesmo computador, onde tal presunção pode ser verificada e mensurada.

            É importante mencionar que, devido à especificação do trabalho, ferramentas de altíssimo nível de abstração foram propositalmente evitadas, visto que mascarariam funcionalidades requeridas pelo enunciado.
            Ainda assim, é relevante mencioná-las, para fins de completude desta seção.
            O módulo \texttt{socketserver} gerencia silenciosamente falhas de conexão em sockets, e seria a principal escolha se não houvesse especificada a necessidade de coordenar manualmente os \emph{sockets}.
            Caso não houvesse a necessidade de utilizar uma \emph{thread} cliente e outra servidora, o módulo \texttt{asyncio} seria uma escolha mais intuitiva.
            Se esta fosse uma aplicação comercial, muitas das funcionalidades já estariam implementadas no framework \emph{Twisted}, direcionado a arquiteturas orientadas a eventos (como é o caso aqui) \cite{WEBSITE:11}.

            Embora a linguagem preveja implementação agnóstica em relação aos sistemas operacionais, esta aplicação foi desenvolvida sob o sistema operacional Ubuntu 14.04 LTS 64-bit, onde a implementação é determinística\cite{WEBSITE:8}.
            Em especial, versões antigas de sistemas Windows podem exibir condições de corrida não-previsíveis.

            O programa foi projetado para ser executado por um interpretador no modo otimizado (\texttt{python -O main.py [args]}).
            Embora o modo não-otimizado produza o mesmo resultado para fins práticos, há diversos gatilhos de depuração (\texttt{if \_\_debug\_\_}) que serão ativados.
            A avaliação pode se tornar cansativa ou tediosa devido à verbosidade das diretivas de depuração.

        %----------------------------------------------------------------------------------------
        %	SECTION 3
        %----------------------------------------------------------------------------------------
        
        \section{Implementação}
        
        Há cinco classes que serviram de fundação para o trabalho.
        O diagrama de classes está representado graficamente na Figura 1.

        \begin{figure}[h]
            \begin{center}
                \includegraphics[width=0.65\textwidth]{placeholder_1} % Include the image placeholder.png
                \caption{Figure caption.}
            \end{center}
        \end{figure}

        A classe \texttt{Process} encapsula funcionalidades dos módulos \texttt{socket} \cite{WEBSITE:7} e \texttt{multiprocessing}.
        É importante observar que este último expõe a mesma \emph{API} tanto para processos, quanto para \emph{threads}.
        Devido aos requerimentos do enunciado, foi utilizado somente o \emph{namespace} \texttt{dummy}, que inicia \emph{user-level threads} dentro do mesmo processo e permite o compartilhamento implícito de memória entre elas.
        Para cada \texttt{Process}, é aberto um total de 3 \emph{threads}: uma cliente, uma servidora e uma principal, responsável pelo gerenciamento dos recursos do processo.
        O encerramento desta última automaticamente interrompe as demais e ativa a coleta de lixo e desalocação de recursos, incluindo os \emph{sockets} previamente alocados.
        
        O autor observou que, a despeito disto, eles permanecem abertos e ocupando o endereço por algum tempo, presumidamente por opção do sistema operacional (\cite{WEBSITE:7}).
        Caso isto ocorra, o programa acionará uma exceção \texttt{ConnectionRefusedError} e encerrará logo em seguida.
        Falhas capturadas pelo interpretador Python, incluindo o comando \texttt{CTRL+C}, provocarão, como reação, a tentativa de fechar todos os \emph{sockets} antes de encerrar a execução.
        Falhas que escapam ao contexto do interpretador (como o sinal \texttt{SIGKILL}) provocarão o encerramento abrupto, caso em que \texttt{ConnectionRefusedError}s são mais prováveis de ocorrer. 

        A classe \texttt{Thread} concentra os métodos executados concorrentemente.
        Em especial, o método \texttt{run()} foi construído desde o princípio de forma limitada ao padrão \emph{thread-safe}.
        Herdam desta classe \texttt{ListenerThread} (orientada a serviços de servidor) e \texttt{EmitterThread} (orientada a serviços de cliente).

        Os objetos que representam os eventos são derivados da classe \texttt{Event}.
        Particularmente, os que representam as mensagens derivam da classe \texttt{Message}.
        São eles: \texttt{SentMessage} (enviada pelo processo que a criou), \texttt{ReceivedMessage} (recebida pelo processo que a criou) e \texttt{AckMessage} (confirmação a ser enviada pelo processo que a criou).
        As mensagens são as responsáveis pela execução, visto que representam os eventos na abstração do mecanismo \emph{Totally Ordered Multicast} enunciada a este trabalho.
        Portanto, é a classe \texttt{ReceivedMessage} a responsável por gravar pertinentemente as mensagens no disco uma vez que estejam aptas.

        O relógio lógico de Lamport é representado pela classe \texttt{LogicalClock}, que encapsula cadeados (\emph{locks}) para a manutenção do caráter \emph{thread-safe} do método \texttt{Thread.run()}.

        Por fim, as mensagens que aguardam execução são armazenadas num objeto \texttt{MessageQueue}, que encapsula uma fila do tipo \emph{FIFO} (\emph{First In, First Out}, "fila indiana") e cadeados para seu acesso concorrente.

        Todos os objetos são pertencentes ao objeto \texttt{Process} que coordena a execução local do programa.
        Isto porque, para garantir o acesso implícito à memória compartilhada, o módulo \texttt{multiprocessing} exige que as estruturas de dados sejam referenciadas pela abstração do processo (e não pela abstração das \emph{threads}).

        A escrita no disco é gerenciada pelo modo \texttt{logging}, que grava num arquivo sugerido pelo próprio usuário como comando.

        Os argumentos passados ao arquivo \texttt{main.py} incluem o nome do arquivo do log onde os eventos serão gravados, o número $n$ de mensagens enviadas por processo, a taxa $\lambda$ de emissão de mensagens por segundo e o total $p$ de processos abertos simultaneamente.

            
        %----------------------------------------------------------------------------------------
        %	SECTION 4
        %----------------------------------------------------------------------------------------
        
        \section{Estudos de Caso}
        
        Os estudos de caso foram executados para todas as combinações dos valores $n \in \{1, 2, 4, 8\}$, $\lambda \in \{100, 1000, 10000\}$ e $p \in \{1, 2, 10\}$. Foram utilizadas as portas de numeração entre 8000 e 8007, por estarem comumente livres na maioria dos sistemas. Os valores podem ser conferidos nas Tabelas 1 a 3. Os logs estão disponíveis para consulta no repositório público onde o trabalho foi hospedado, no diretório \texttt{logs/}.

        



        As Figuras 2 a 4 demonstram de forma gráfica a distribuição dos resultados. 
        
        
        %----------------------------------------------------------------------------------------
        %	SECTION 5
        %----------------------------------------------------------------------------------------
        
        \section{Considerações Finais}
        
        
        The most obvious source of experimental uncertainty is the limited precision of the balance. Other potential sources of experimental uncertainty are: the reaction might not be complete; if not enough time was allowed for total oxidation, less than complete oxidation of the magnesium might have, in part, reacted with nitrogen in the air (incorrect reaction); the magnesium oxide might have absorbed water from the air, and thus weigh ``too much." Because the result obtained is close to the accepted value it is possible that some of these experimental uncertainties have fortuitously cancelled one another.

        Random citation \cite{WEBSITE:2} embeddeed in text.

        %----------------------------------------------------------------------------------------
        %	BIBLIOGRAPHY
        %----------------------------------------------------------------------------------------
        
        \bibliographystyle{apalike}
        \bibliography{sd3_report}
        
        %----------------------------------------------------------------------------------------


    \end{document}